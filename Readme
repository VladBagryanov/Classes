Детали реализации
От вас требуется реализовать шаблонный класс Vector с единственным шаблонным параметром - типом хранящихся элементов. При реализации можно (и даже нужно) пользоваться обобщенными алгоритмами из STL (std::copy, std::fill и т.п.), но нельзя использовать стандартные контейнеры. Будет проверяться корректность мультипликативной схемы расширения массива с коэффициентом 2. В базовой версии ручное управление временем жизни объектов не требуется (см. доп. задание). Класс должен поддерживать следующий функционал:
\begin{itemize}
\item Конструктор по умолчанию - создает пустой массив;
\item Явный конструктор от числа - создает массив заданного размера заполненный объектами, сконструированными по умолчанию;
\item Конструктор, принимающий size и value (именно в этом порядке) - создает массив длины size, заполненный элементами со значением value;
\item Шаблонный конструктор, принимающий пару итераторов - создает копию переданного диапазона;
Важно: объявление этого конструктора должно иметь вид

template <class Iterator, class = std::enable_if_t<std::is_base_of_v<std::forward_iterator_tag, typename std::iterator_traits<Iterator>::iterator_category>>>

Vector(Iterator first, Iterator last)

Это делает конструктор доступным только в случае, когда на вход приходят два Forward итератора.

\item Конструктор от std::initializer_list;
\item Правило "пяти";
\item Методы Size, Capacity, Empty;
\item Константный и неконстантный оператор доступа по индексу []. Неконстантный должен позволять изменять полученный элемент;
\item Константный и неконстантный метод доступа по индексу At. При выходе за границы массива должен бросать исключение std::out_of_range;
\item Методы Front() и Back()
\item доступ к первому и последнему элементам (тоже по две версии).
\item Метод Data()
возвращает указатель на начало массива.
\item Метод Swap(other)
обменивает содержимое с другим массивом other;
\item Метод Resize(new_size)
изменяет размер на new_size. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью new_size. Недостающие элементы конструируются по умолчанию.
\item Метод Resize(new_size, value)
то же, что и Resize(new_size), но в случае new_size > size заполняет недостающие элементы значением value.
\item Метод Reserve(new_cap)
изменяет вместимость на max(new_cap, текущая вместимость). Размер при этом не изменяется.
\item Метод ShrinkToFit()
уменьшает capacity до size.
\item Метод Clear()
устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.
\item Методы PushBack(const T&) и PushBack(T&&)
добавляет новый элемент в конец массива.
\item Метод PopBack()
удаляет последний элемент.
\item Операции сравнения (<, >, <=, >=, ==, !=), задающие лексикографический порядок.
\item Также реализуйте поддержку итераторов и методы для работы с ними: begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend(). begin()-end(), rbegin()-rend() должны иметь две версии, возвращающие константные и неконстантные итераторы.

\item Внутри класса Vector определите типы-члены ValueType, Pointer, ConstPointer, Reference, ConstReference, SizeType, Iterator, ConstIterator.
\end{itemize}

Гарантии безопасности
Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора. Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности.
